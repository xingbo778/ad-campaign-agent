"""
Unified schema module for the Advertising Campaign Agent system.

This module defines all shared data models used across:
- Orchestrator and its clients
- All MCP services (product, creative, strategy, meta, optimizer, logs, validator)

All models use Pydantic v2 BaseModel for validation and serialization.
Models are designed for forward compatibility and cross-service consistency.
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Literal, Union, Annotated


class CampaignSpec(BaseModel):
    """
    Campaign specification model - the first structured output from the orchestrator LLM.
    
    This model represents the parsed user intent and flows through:
    product → creative → strategy → meta_service
    
    Usage:
        - Generated by the orchestrator LLM from user_query
        - Used as input to product service for product selection
        - Passed to creative service for creative generation
        - Used by strategy service for campaign strategy
        - Final input to meta_service for platform-specific campaign creation
    """
    user_query: str = Field(..., description="Original user intent/query")
    platform: Literal["meta", "tiktok", "google"] = Field(..., description="Target advertising platform")
    budget: float = Field(..., description="Campaign budget")
    objective: Literal["conversions", "sales", "traffic", "leads"] = Field(..., description="Campaign objective")
    category: str = Field(..., description="Product category")
    time_range: Optional[Dict[str, str]] = Field(None, description="Time range with 'start' and 'end' keys")
    metadata: Optional[Dict] = Field(None, description="Additional metadata for the campaign")


class Product(BaseModel):
    """
    Product model representing a single product in the catalog.
    
    Used by:
        - Product service: returns products from selection
        - Creative service: generates creatives for products
        - Strategy service: considers products in strategy generation
    
    Usage:
        - Product service returns List[Product] grouped by ProductGroup
        - Creative service uses product_id to generate platform-specific creatives
    """
    product_id: str = Field(..., description="Unique product identifier")
    title: str = Field(..., description="Product title/name")
    description: str = Field(..., description="Product description")
    price: float = Field(..., description="Product price")
    category: str = Field(..., description="Product category")
    image_url: Optional[str] = Field(None, description="URL to product image")
    metadata: Optional[Dict] = Field(None, description="Additional product metadata")


class ProductGroup(BaseModel):
    """
    Group of products organized by priority/score level.
    
    Used by:
        - Product service: returns products grouped by priority
        - Orchestrator: selects products from high/medium/low groups
        - Strategy service: considers product groups for budget allocation
    
    Usage:
        - Product service returns List[ProductGroup] with products sorted by priority
        - Orchestrator typically prioritizes 'high' group products
    """
    group: Literal["high", "medium", "low"] = Field(..., description="Priority group level")
    products: List[Product] = Field(..., description="List of products in this group")
    score_range: Optional[tuple[float, float]] = Field(None, description="Score range tuple (min, max) for this group")
    reasoning: Optional[str] = Field(None, description="Reasoning for grouping these products")


class Creative(BaseModel):
    """
    Creative asset model for advertising content.
    
    Used by:
        - Creative service: generates and returns creatives
        - Meta service: uses creatives to create platform-specific ads
        - Optimizer service: tracks creative performance
    
    Usage:
        - Creative service generates multiple variants (A, B, C) per product
        - Each creative is platform-specific (meta/tiktok/google)
        - style_profile contains creative policy rules from creative_policy.yaml
    """
    creative_id: Optional[str] = Field(None, description="Unique creative identifier")
    product_id: str = Field(..., description="Associated product ID")
    platform: Literal["meta", "tiktok", "google"] = Field(..., description="Target platform for this creative")
    variant_id: str = Field(..., description="Variant identifier (e.g., 'A', 'B', 'C')")
    primary_text: str = Field(..., description="Primary text content for the creative")
    headline: Optional[str] = Field(None, description="Creative headline")
    image_url: Optional[str] = Field(None, description="URL to creative image asset")
    style_profile: Optional[Dict] = Field(None, description="Style profile from creative_policy.yaml")
    ab_group: Optional[str] = Field(None, description="A/B test group: 'control' or 'variant'")


class AbstractStrategy(BaseModel):
    """
    Abstract/high-level campaign strategy model.
    
    Used by:
        - Strategy service: generates abstract strategy
        - Orchestrator: coordinates strategy across services
        - Meta service: converts abstract strategy to platform-specific strategy
    
    Usage:
        - Strategy service generates this from campaign objective and budget
        - budget_split maps variant IDs (A, B, C) to budget percentages
        - constraints may include targeting, timing, or other limitations
    """
    objective: str = Field(..., description="Campaign objective (conversions, traffic, etc.)")
    budget_split: Dict[str, float] = Field(..., description="Budget split by variant ID (e.g., {'A': 0.4, 'B': 0.3, 'C': 0.3})")
    bidding_strategy: str = Field(..., description="Bidding strategy description")
    constraints: Optional[Dict] = Field(None, description="Strategy constraints (targeting, timing, etc.)")
    metadata: Optional[Dict] = Field(None, description="Additional strategy metadata")


class PlatformStrategy(BaseModel):
    """
    Platform-specific campaign strategy model.
    
    Used by:
        - Strategy service: generates platform-specific strategies
        - Meta service: creates actual campaigns using this strategy
        - Optimizer service: optimizes based on platform strategy
    
    Usage:
        - campaign_structure contains platform-specific hierarchy (adset/campaign/ad for Meta)
        - optimization_goal is platform-specific (e.g., 'CONVERSIONS' for Meta)
        - targeting and placements are platform-specific dictionaries/lists
    """
    platform: Literal["meta", "tiktok", "google"] = Field(..., description="Target advertising platform")
    campaign_structure: Dict = Field(..., description="Platform-specific campaign structure (adset/campaign/ad hierarchy)")
    optimization_goal: str = Field(..., description="Platform-specific optimization goal")
    targeting: Optional[Dict] = Field(None, description="Platform-specific targeting criteria")
    placements: Optional[List[str]] = Field(None, description="List of ad placements")
    metadata: Optional[Dict] = Field(None, description="Additional platform-specific metadata")


class ErrorResponse(BaseModel):
    """
    Standard error response model for all services.
    
    Used by:
        - All services: return this on errors
        - Orchestrator: handles error responses from services
        - Logs service: logs error events
    
    Usage:
        - status is always "error" for error responses
        - error_code is a service-specific error code
        - message is human-readable error description
        - details may contain additional error context
    """
    status: Literal["error"] = Field(..., description="Response status (always 'error')")
    error_code: str = Field(..., description="Service-specific error code")
    message: str = Field(..., description="Human-readable error message")
    details: Optional[Dict] = Field(None, description="Additional error details")


class LogEvent(BaseModel):
    """
    Log event model for tracking system operations.
    
    Used by:
        - All services: log their operations
        - Logs service: stores and retrieves log events
        - Orchestrator: logs orchestration flow
    
    Usage:
        - event_id is auto-generated if not provided
        - timestamp is ISO format string
        - stage indicates the workflow stage
        - service is the service name that generated the log
        - request/response contain the actual data exchanged
    """
    event_id: Optional[str] = Field(None, description="Unique event identifier")
    timestamp: str = Field(..., description="Event timestamp (ISO format)")
    stage: Literal["intent", "product", "creative", "strategy", "meta", "optimizer", "orchestrator"] = Field(..., description="Workflow stage")
    service: str = Field(..., description="Service name that generated the log")
    request: Optional[Dict] = Field(None, description="Request data")
    response: Optional[Dict] = Field(None, description="Response data")
    success: bool = Field(..., description="Whether the operation was successful")
    metadata: Optional[Dict] = Field(None, description="Additional log metadata")


__all__ = [
    "CampaignSpec",
    "Product",
    "ProductGroup",
    "Creative",
    "AbstractStrategy",
    "PlatformStrategy",
    "ErrorResponse",
    "LogEvent",
]

